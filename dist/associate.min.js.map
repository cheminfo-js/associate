{"version":3,"sources":["webpack:///associate/webpack/universalModuleDefinition","webpack:///associate/webpack/bootstrap 3c1bebd8425cefdbc616","webpack:///associate/./src/index.js","webpack:///associate/./~/process/browser.js","webpack:///associate/./src/util/simpleClustering.js","webpack:///associate/./src/associate.js","webpack:///associate/./src/util/combinate.js","webpack:///associate/./src/util/createHierarchy.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;;AAEA,kBAAiB,kBAAkB;AACnC;AACA,sBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0DAAyD,yBAAyB;AAClF;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;;;;;;;;;ACrDA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;AC/JtC;AACA;AACA;;AAEA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,QAAQ;AAChC,6BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,gBAAgB;AAChC;AACA,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,iBAAiB;AACxC;AACA,2BAA0B,sBAAsB;AAChD;AACA,+BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,KAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,WAAW;AACjC;AACA;AACA,4BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACjHA;;AAEA;;AAEA;;;AAGA;AACA,qBAAoB;AACpB;AACA;AACA;AACA,cAAa,EAAE;AACf;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,cAAa;AACb;AACA,UAAS;AACT;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB,kHAAkH;AACvI;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA,sBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,gCAAgC;AACnD;AACA,2BAA0B,qBAAqB;AAC/C,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,sCAAsC,oBAAoB,YAAY;AACpG;AACA;AACA;AACA,gFAA+E;AAC/E;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA;AACA;;;;;;;ACjCA;AACA;AACA,kBAAiB,iBAAiB;AAClC,sBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E","file":"associate.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"associate\"] = factory();\n\telse\n\t\troot[\"associate\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 3c1bebd8425cefdbc616\n **/","'use strict';\n\nmodule.exports = {\n    process\n};\n\nvar simpleClustering=require('./util/simpleClustering.js');\n\n\nvar associate=require('./associate.js');\nvar createHierarchy=require('./util/createHierarchy.js');\n\nfunction process(sources, targets, options) {\n    \n    // we will construct a matrix with the valud sources / targerts\n    var associationMatrix=new Array();\n    for (var i=0; i<sources.length; i++) {\n        associationMatrix.push(new Array(targets.length).fill(0))\n    };\n    \n    for (var i=0; i<sources.length; i++) {\n        var source=sources[i];\n        for (var j=0; j<targets.length; j++) {\n            var target=targets[j];\n            if (! options.candidateFunction || options.candidateFunction(source, target)) {\n                associationMatrix[i][j]=((i+1)<<16)+(j+1);\n            }\n        }\n    }\n\n    // we need now to split in sub matrices in order to accelerate the process\n    // TODO : Waiting for working project\n    var submatrices=simpleClustering(associationMatrix, {threshold:0,out:\"values\"});\n    var submatrices=[associationMatrix];\n\n    \n    var results=[];\n    // now we need to calculate the tree\n    for (var matrix of submatrices) {\n        var hierarchy = createHierarchy(matrix);\n        var result=associate(hierarchy, sources, targets, options);\n        results.push(result);\n    }\n    \n    // if we just want to flatten the best matches\n    var best=[];\n    results.forEach(function(result) {\n        for (var key in result.best) {\n            best[key>>0]=result.best[key];\n        }\n    })\n    \n    return best;\n}\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n    try {\n        cachedSetTimeout = setTimeout;\n    } catch (e) {\n        cachedSetTimeout = function () {\n            throw new Error('setTimeout is not defined');\n        }\n    }\n    try {\n        cachedClearTimeout = clearTimeout;\n    } catch (e) {\n        cachedClearTimeout = function () {\n            throw new Error('clearTimeout is not defined');\n        }\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Created by acastillo on 8/8/16.\n */\n\n// should use directly from the web : https://github.com/mljs/simple-clustering/blob/6ac43e180024e1efc6a5edfdace6a53d06513afd/src/index.js\n\n\n\n'use strict';\n\nconst defOptions = {\n    threshold:0,\n    out:\"assignment\"\n};\n//TODO Consider a matrix of distances too\nmodule.exports = function fullClusterGenerator(conMat, opt) {\n    const options = Object.assign({}, defOptions, opt);\n    var clList, i, j, k;\n    if(typeof conMat[0] === \"number\"){\n        clList = fullClusterGeneratorVector(conMat);\n    }\n    else{\n        if(typeof conMat[0] === \"object\"){\n            var nRows = conMat.length;\n            var conn = new Array(nRows*(nRows+1)/2);\n            var index = 0;\n            for(var i=0;i<nRows;i++){\n                for(var j=i;j<nRows;j++){\n                    if(conMat[i][j]>options.threshold)\n                        conn[index++]= 1;\n                    else\n                        conn[index++]= 0;\n                }\n            }\n            clList = fullClusterGeneratorVector(conn);\n        }\n    }\n    if (options.out === \"indexes\" || options.out === \"values\") {\n        var result = new Array(clList.length);\n        for(i=0;i<clList.length;i++){\n            result[i] = [];\n            for(j=0;j<clList[i].length;j++){\n                if(clList[i][j] != 0){\n                    result[i].push(j);\n                }\n            }\n        }\n        if (options.out === \"values\") {\n            var resultAsMatrix = new Array(result.length);\n            for (i = 0; i<result.length;i++){\n                resultAsMatrix[i]=new Array(result[i].length);\n                for(j = 0; j < result[i].length; j++){\n                    resultAsMatrix[i][j]=new Array(result[i].length);\n                    for(k = 0; k < result[i].length; k++){\n                        resultAsMatrix[i][j][k]=conMat[result[i][j]][result[i][k]];\n                    }\n                }\n            }\n            return resultAsMatrix;\n        }\n        else{\n            return result;\n        }\n    }\n\n    return clList;\n\n}\n\nfunction fullClusterGeneratorVector(conn){\n    var nRows = Math.sqrt(conn.length*2+0.25)-0.5;\n    var clusterList = [];\n    var available = new Array(nRows);\n    var remaining = nRows, i=0;\n    var cluster = [];\n    //Mark all the elements as available\n    for(i=nRows-1;i>=0;i--){\n        available[i]=1;\n    }\n    var nextAv=-1;\n    var toInclude = [];\n    while(remaining>0){\n        if(toInclude.length===0){\n            //If there is no more elements to include. Start a new cluster\n            cluster = new Array(nRows);\n            for(i = 0;i < nRows ;i++)\n                cluster[i]=0;\n            clusterList.push(cluster);\n            for(nextAv = 0;available[nextAv]==0;nextAv++){};\n        }\n        else{\n            nextAv=toInclude.splice(0,1);\n        }\n        cluster[nextAv]=1;\n        available[nextAv]=0;\n        remaining--;\n        //Copy the next available row\n        var row = new Array(nRows);\n        for( i = 0;i < nRows;i++){\n            var c=Math.max(nextAv,i);\n            var r=Math.min(nextAv,i);\n            //The element in the conn matrix\n            //console.log(\"index: \"+r*(2*nRows-r-1)/2+c)\n            row[i]=conn[r*(2*nRows-r-1)/2+c];\n            //There is new elements to include in this row?\n            //Then, include it to the current cluster\n            if(row[i]==1&&available[i]==1&&cluster[i]==0){\n                toInclude.push(i);\n                cluster[i]=1;\n            }\n        }\n    }\n    return clusterList;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util/simpleClustering.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = associate;\n\nvar combinate = require('./util/combinate.js')\n\n\n/**\n * @param source = {a:[], b:[], c:[], ...}\n * @param target = [1,2,3,4,5,6]\n * @param maxTarget integer of max association\n * @param minTarget integer of min association\n * @returns {*} return the top 3 best association\n */\n\nvar DEBUG=0;\n\n\nfunction associate(links, dataSources, dataTargets, options) {\n    if (!dataTargets) options=dataSources;\n    \n    var options=options || {};\n    var minTarget=options.minTarget || 0;\n    var maxTarget=options.maxTarget || 2;\n    var maxCounts=options.maxCounts;\n    var sizeCounts=maxTarget-minTarget+1;\n    if (options.maxCounts && options.maxCounts.length!==sizeCounts) {\n        throw new Error('The maxCounts parameter must have exactly the length '+sizeCounts);\n    }\n    var scoreFunction=options.scoreFunction;\n\n    var result={\n        stat:{\n            numberOperation:0,\n            numberHits:0\n        }\n    };\n    \n    var currentBestScore=0;\n    var currentAssociation;\n    var currentCounts=new Array(sizeCounts).fill(0);\n    var sources=[];\n    for (var key in links) {\n        sources.push(\n            {\n                id: key,\n                possibleLinks: links[key],\n                possibleTargets: combinate(links[key], minTarget, maxTarget),\n                currentTargetPosition: 0,\n                currentTotalTargetsAssigned: 0,\n                currentTotalScore: 1\n            }\n        );\n    }\n\n    // we will calculate the scores for each targets\n    if (scoreFunction) {\n        if (DEBUG>1) console.log(\"Calculating scores\");\n        sources.forEach(function(source) {\n            source.possibleTargets.forEach(function(target) {\n                var s = (dataSources!==undefined) ? dataSources[source.id] : source.id;\n                var t = target.targets.map(function(target) {\n                    return dataTargets ? dataTargets[target] : target;\n                });\n                target.score = scoreFunction(s, t);\n            });\n            source.possibleTargets.sort((a,b) => b.score-a.score);\n        });\n    }\n\n\n    \n    // console.log(JSON.stringify(sources,\"   \"));\n    \n    var targets = {};\n    sources.map(function(source) {\n        source.possibleLinks.map(function(targetID) {\n            if (! targets[targetID]) {\n                targets[targetID]={\n                    isUsed: false\n                };\n            }\n        });\n    });\n    var numberOfTargets=Object.keys(targets).length;\n    \n    var currentSource=-1;\n    \n    var limit=5000000;\n    do {\n        if (currentSource < (sources.length-1)) {\n            currentSource++;\n            sources[currentSource].currentTargetPosition=-1;\n        }\n\n        var badCandidate=false;\n        do {\n            result.stat.numberOperation++;\n            var goingBack=false;\n            // before changing anything we need to unset targets assignment;\n            if (! badCandidate) unsetTargetAssignment(sources, targets, currentSource);\n            badCandidate=false;\n            sources[currentSource].currentTargetPosition++;\n            // need to recalculate the information for this new hypothesis\n            if (sources[currentSource].currentTargetPosition===sources[currentSource].possibleTargets.length) {\n                // we tried all the possibilities, we need to go back\n                currentSource--;\n                goingBack=true;\n            } else {\n                var source=sources[currentSource];\n                if (targetsNotAssigned(targets, source.possibleTargets[source.currentTargetPosition].targets)) {\n                    source.currentTotalTargetsAssigned=(currentSource>0) ? sources[currentSource-1].currentTotalTargetsAssigned:0;\n                    source.currentTotalTargetsAssigned+=source.possibleTargets[source.currentTargetPosition].targets.length;\n\n                    // we could check if we used the quota\n                    var targetLength=source.possibleTargets[source.currentTargetPosition].targets.length;\n                    if (maxCounts && currentCounts[targetLength]>=maxCounts[targetLength]) {\n                        badCandidate=true;\n                    } else if ((source.currentTotalTargetsAssigned + (sources.length-currentSource-1) * maxTarget) < numberOfTargets) { // can we still assign all the targets ?\n                        badCandidate=true;\n                    } else {\n                        // CALCULATE SCORE\n                        if (scoreFunction) {\n                            source.currentTotalScore=(currentSource>0) ? sources[currentSource-1].currentTotalScore:1;\n                            var score=source.currentTotalScore*=source.possibleTargets[source.currentTargetPosition].score;\n                            if (score<currentBestScore) {\n                                badCandidate=true;\n                            }\n                        }\n                    }\n                } else {\n                    badCandidate=true;\n                }\n                if (! badCandidate) {\n                    setTargetAssignment(sources, targets, currentSource);\n                }\n            }\n            // console.log('badCandidate: '+badCandidate, 'goingBack: '+goingBack, currentSource);\n        } while ((badCandidate || goingBack) && currentSource>=0);\n        \n        if (! badCandidate && currentSource === (sources.length-1)) {\n            // we have a candidate !\n            result.stat.numberHits++;\n            if (scoreFunction) {\n                var score=sources[currentSource].currentTotalScore;\n                if (score > currentBestScore) {\n                    currentBestScore = score;\n                    currentAssociation = {};\n                    sources.forEach(function(source) {\n                        currentAssociation[source.id]=source.possibleTargets[source.currentTargetPosition];\n                    })\n                }\n                if (DEBUG>1) console.log(\"Current best score: \"+currentBestScore);\n            }\n            if (DEBUG>1) debugCurrentTargets(sources, targets);\n        }\n    } while (limit-- > 0 && currentSource >= 0);\n    result.stat.score=currentBestScore;\n    result.best=currentAssociation;\n\n    if (DEBUG>0) console.log(\"Number of operation\", result.stat.numberOperation);\n    if (DEBUG>0) console.log(\"Total: \", result.stat.numberHits);\n    \n    return result;\n    \n    \n    function targetsNotAssigned(targets, array) {\n        for (var id of array) {\n            if (targets[id].isUsed) return false;\n        }\n        return true;\n    }\n    \n    function unsetTargetAssignment() {\n        var source=sources[currentSource];\n        if (! source || ! source.possibleTargets[source.currentTargetPosition]) return;\n        var currentTargets=source.possibleTargets[source.currentTargetPosition].targets;\n        currentCounts[currentTargets.length]--;\n        currentTargets.forEach(function(id) {\n            if (DEBUG>4) console.log('unset: ',id);\n            targets[id].isUsed=false;\n        });\n    }\n\n    function setTargetAssignment() {\n        var source=sources[currentSource];\n        if (! source || ! source.possibleTargets[source.currentTargetPosition]) return;\n        var currentTargets=source.possibleTargets[source.currentTargetPosition].targets;\n        currentCounts[currentTargets.length]++;\n        currentTargets.forEach(function(id) {\n            if (DEBUG>4) console.log('set: ',id);\n            targets[id].isUsed=true;\n        });\n    }\n    \n    function debugCurrentTargets(sources, targets) {\n        console.log('----------- Source current association ----------')\n        for (var i=0; i<sources.length; i++) {\n            var source=sources[i];\n            console.log(\n                source.currentTargetPosition,\n                source.possibleTargets[source.currentTargetPosition].targets,\n                'Total targets assigned:'+source.currentTotalTargetsAssigned);\n        }\n        var usedTargets=[];\n        for (var key in targets) {\n            if (targets[key].isUsed) usedTargets.push(key);\n        }\n        console.log(\"Used targets: \", usedTargets);\n        console.log(\"Current counts: \", currentCounts);\n    }\n}\n\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/associate.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * This method will create all possible combination starting from an array of values\n * Having between min and max elements\n * @param array\n * @param min\n * @param max\n */\n\nmodule.exports=function(array, min, max) {\n    var results=[];\n    for (var i=min; i<=Math.min(max, array.length); i++) {\n        if (i===0) {\n            results.push({targets:[], score: 1});\n        } else {\n            var indexes=new Array(i).fill(0);\n            var position=0;\n            do {\n                while(position<(i-1)) {\n                    position++;\n                    indexes[position]=indexes[position-1]+1;\n                }\n                // we append the result\n                results.push({targets: indexes.map(function(index) {return array[index]}), score: 1});\n                // we increment the current position and go back in case we reached the maximum\n                do {\n                    indexes[position]++;\n                    if (indexes[position]!==(array.length-i+position+1)) break; // didn't reach maximum\n                    position--;\n                } while (position>=0);\n            } while (position>=0);\n        }\n    }\n    return results;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util/combinate.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = function createHierarchy(matrix) {\n    var results={};\n    for (var i=0; i<matrix.length; i++) {\n        for (var j=0; j<matrix[0].length; j++) {\n            if (matrix[i][j]>0) {\n                var row=(matrix[i][j] >> 16) - 1;\n                var column=(matrix[i][j] & 0b1111111111111111) - 1;\n                if (! results[row]) {\n                    results[row]=[];\n                }\n                results[row].push(column);\n            }\n        }\n    }\n    return results;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util/createHierarchy.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}